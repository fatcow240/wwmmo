//
// Copyright (c) 2012, Dean Harding (dean@codeka.com.au)
//

// TODO: separate these into separate packages?
package warworlds;

//
// This is used when you first connect, we display some news, important announcements,
// stuff of that nature.
//
message MessageOfTheDay
{
    required string message = 1;
    required string last_update = 2; // last update date (in ISO string format)
}


//
// Contains details about an empire. Their "display" name, race (I guess?), display colour
// and stuff like that.
//
message Empire
{
    // A unique identifier for the empire, useful for referencing him in other parts of the
    // system. This won't be present in the initial "PUT"
    optional string key = 1;

    // The "display" name for the player, which is what other players see.
    required string display_name = 2;

    // The player's Google Account identifier (which is actually unique of their email address)
    optional string user = 3;

    // The player's email address
    optional string email = 4;

    enum EmpireState
    {
        INITIAL = 1;
        REGISTERED = 2;
        BANNED = 3;
    }

    required EmpireState state = 5;
}


//
// The "hello" message is returned when you first connect to the game.
//
message Hello
{
    // The current message of the day.
    required MessageOfTheDay motd = 1;

    // If specified, the Empire you're currently logged in as (if not specified, it means
    // you haven't set up an empire yet, and you should do that before anything else...)
    optional Empire empire = 2;

    // The list of colonies your empire owns. Typically, you'll want to start the
    // starfield view centred on one of your own colonies...
    repeated Colony colonies = 3;

    // The ClientID and token you'll use to connect via the Channel API for chats (and
    // possibly other things..?)
    optional string channel_client_id = 4;
    optional string channel_token = 5;
}

//
// Contains details about a device's registration with C2DM so that we can send you
// messages and stuff (e.g. when your planet is under attack, etc)
//
message DeviceRegistration
{
    // Unique identifier for this particuilar registration (similar to device_registration_id,
    // but that's specific to C2DN and is kind a long and unweildy string).
    optional string key = 1;

    // The identifier of the device. You can have multiple accounts on one device, this
    // will then refer to the device itself.
    required string device_id = 2;

    // The identifier of this *registration*. You can register one account on one device,
    // but you could have the same account on multiple devices, too.
    required string device_registration_id = 3;

    // The value of android.os.Build.MODEL for this device
    required string device_model = 4;

    // The value of android.os.Build.MANUFACTURER for this device
    required string device_manufacturer = 5;

    // The value of android.os.Build.DISPLAY for this device
    required string device_build = 6;

    // The value of android.os.Build.VERSION.RELEASE for this device (note that this can
    // change if you upgrade the OS without re-registering your device!)
    required string device_version = 7;

    // If set, this is the user that the device belongs to. This is usually only returned
    // when you fetch registrations, adding registrations you can obviously only register
    // to yourself (i.e. if this is present, it's ignored anyway)
    optional string user = 8;
}

//
// Represents a collection of device registrations.
//
message DeviceRegistrations
{
    repeated DeviceRegistration registrations = 1;
}

//
// Represents a message that we'll be sending to a device.
//
message DeviceMessage
{
    required string message = 1;
}


//
// A chat message, who it's from, the kind of message and whatnot.
//
message ChatMessage
{
    required string message = 1;
}


//
// Represents a "sector" of space, containing a number of stars and whatnot.
message Sector
{
    // these are the (x,y) coordinates of the sector. (0,0) is the "centre" of the universe,
    // (1,1) is one sector up and to the right, and so on.
    required int64 x = 1;
    required int64 y = 2;

    // number of colonies in this sector
    optional int32 num_colonies = 5;

    // the collection of stars in this sector.
    repeated Star stars = 3;

    // a collection of colonies in this sector (TODO: full colony details? probably not needed...)
    repeated Colony colonies = 4;
}

//
// Represents a single star within a sector. The star can have a few planets, though this
// is optional (we don't always return the list of planets with a star).
//
message Star
{
    // the identifier of the star, unique throughout the universe.
    optional string key = 1;

    // the sector this star is contained within
    optional int64 sector_x = 11;
    optional int64 sector_y = 12;

    // the name of the star
    optional string name = 2;

    // the classification of this star. The order of these enum values
    // must correspond to the order of the StarTypes defined in sector.py
    enum CLASSIFICATION
    {
        BLUE = 0;
        WHITE = 1;
        YELLOW = 2;
        ORANGE = 3;
        RED = 4;
        NEUTRON = 5;
        BLACKHOLE = 6;
    }
    optional CLASSIFICATION classification = 3;

    // the colour of the star, as an RGB value
    optional uint32 colour = 4;

    // the apparent "size" of the star (which is really just a display thing)
    optional int32 size = 5;

    // the offset from the left edge of the sector, in pixels
    required int32 offset_x = 6;

    // the offset from the bottom edge of the sector, in pixels
    required int32 offset_y = 7;

    // the number of planets orbiting this star (useful for knowing whether there are
    // actually planets, and the planets field is just empty, or whether there are no
    // planets anyway).
    optional int32 num_planets = 8;

    // the collection of planets orbiting this star (may be empty)
    repeated Planet planets = 9;

    // collection of colonies on our planet(s)
    repeated Colony colonies = 10;

    // collection of buildings in our colonies.
    repeated Building buildings = 13;

    // collection of EmpirePresences details the presences of the empire(s) in this solar system.
    repeated EmpirePresence empires = 14;

    // collection of BuildRequests for colonies in this star
    repeated BuildRequest build_requests = 15;

    // List of fleets located in this star
    repeated Fleet fleets = 16;
}

//
// Represents a planet in the star system. A planet orbits a \c Star which in turn belongs
// to a \c Sector.
//
message Planet
{
    // The key of the planet, unique throughout the universe.
    required string key = 1;

    // The "index" of the planet represents how far it is from the sun. Planets are always
    // in monotonically increasing order of distance (0, 1, 2, 3, etc)
    required int32 index = 2;

    // The various different "kinds" of planets. Planets are spawned in increasing order
    // of probability (so "terran" is most likely, "gas giant" least likely).
    enum PLANET_TYPE
    {
        GASGIANT = 1;
        RADIATED = 2;
        INFERNO = 3;
        ASTEROIDS = 4;
        WATER = 5;
        TOXIC = 6;
        DESERT = 7;
        SWAMP = 8;
        TERRAN = 9;
    }

    required PLANET_TYPE planet_type = 3;

    // The size of the planet. Certain planet_type's are predisposed to be certain sizes
    // (e.g. GASGIANT is predisposed to being big, etc) but planets will still vary in exact size.
    optional int32 size = 4;

    // How "congenial" is this planet to supporting population
    optional int32 population_congeniality = 5;

    // How "congenial" is this planet to supporting farming
    optional int32 farming_congeniality = 6;

    // How "congenial" is this planet to supporting mining
    optional int32 mining_congeniality = 7;
}

//
// Represents a list of sectors.
//
message Sectors
{
    repeated Sector sectors = 1;
}

//
// Represents the details of an empire's "presence" in a star. For example, keeps track
// of stored goods, etc.
//
message EmpirePresence
{
    required string key = 1;
    optional string empire_key = 2;
    optional string star_key = 3;

    optional float total_goods = 4;
    optional float total_minerals = 5;
}

//
// Represents a request to colonize a planet. PUT this to /colonies to colonize.
//
message ColonizeRequest
{
    // The planet you want to colonize
    required string planet_key = 1;

    // The star containing the planet you want to colonize.
    required string star_key = 2;
}

//
// Represents a colony that's on a planet.
//
message Colony
{
    // The key of this colony, which you can use to refer to it directly.
    optional string key = 1;

    // The key of the empire that owns this colony.
    required string empire_key = 2;

    // The key of the planet and star this colony belongs to.
    optional string planet_key = 3;
    optional string star_key = 4;

    // In the backend, population is actually stored as a floating point value, but
    // we don't care about that kind of accuracy.
    optional float population = 5;

    // Time, in seconds since Unix epoch, that this colony was last simulated (i.e.
    // when the population and such was last calculated)
    optional int64 last_simulation = 6;

    // The "focus" of this colony. These numbers must add up to 1.0 and represent
    // the percentage of the population that is focussed on the given task.
    optional float focus_population = 7;
    optional float focus_farming = 8;
    optional float focus_mining = 9;
    optional float focus_construction = 10;

    // After simulating, these will contain the delta values (i.e. how much do the goods
    // or whatever changed in this colony) per hour.
    optional float delta_population = 11;
    optional float delta_goods = 12;
    optional float delta_minerals = 13;
}


//
// A collection of Colonies
//
message Colonies
{
    repeated Colony colonies = 1;
}


//
// A request to build something (a building, a ship, etc)
//
message BuildRequest
{
    optional string key = 1;

    // The key of the colony you're trying to build at. Must have a shipyard to build
    // a ship.
    required string colony_key = 2;

    // The empire this build operation belongs to.
    required string empire_key = 3;

    // What are you trying to build? A building or a ship?
    // The values here should be in sync with com.codeka.warworlds.model.Design.DesignKind.
    enum BUILD_KIND
    {
        BUILDING = 1;
        SHIP = 2;
    }
    required BUILD_KIND build_kind = 4;

    // The name of the design you're trying to build
    required string design_name = 5;

    // The date/time this build request started and the current predicted time of completion
    optional int64 start_time = 6;
    optional int64 end_time = 7;

    // this is the "progress" of the build, from 0 (just started) to 1.0 (complete). It's not
    // always going to relate to start_time/end_time (due to lack of resources, changing focus
    // etc etc)
    optional float progress = 8;
}


//
// A build queue is basically just a list of BuildRequests.
//
message BuildQueue
{
    repeated BuildRequest requests = 1;
}


//
// Represents a completed building in a colony.
//
message Building
{
    // The unique key of this building.
    required string key = 1;

    // The key of the colony to which this building belongs.
    required string colony_key = 2;

    // The name of the design of this building (defined in data/buildings.xml)
    required string design_name = 3;
}


//
// A fleet represents one or more ships of the same(?) design.
//
message Fleet
{
    // The unique key for this fleet
    required string key = 1;

    // The key of the empire who owns this fleet
    required string empire_key = 2;

    // The name of the ship design of the ship(s) in this fleet
    optional string design_name = 3;

    // The number of ships in this fleet.
    optional int32 num_ships = 4;

    // The current state of the fleet: idle == orbiting a star, moving == moving
    // between stars, attacking == attacking an enemy fleet, colony, etc
    enum FLEET_STATE
    {
        IDLE = 1;
        MOVING = 2;
        ATTACKING = 3;
    }
    optional FLEET_STATE state = 5;

    // The time this fleet was moved into the current state (used to determine things like
    // distance between planets when moving, etc)
    optional int64 state_start_time = 6;

    // The star this fleet is associated with. If moving, star_key is the star we're moving
    // FROM and destination_star_key is the star we're moving TO.
    optional string star_key = 7;
    optional string destination_star_key = 8;

    // If in attacking state, this is the target fleet or colony we're attacking
    optional string target_fleet_key = 9;
    optional string target_colony_key = 10;
}
