package au.com.codeka.warworlds.model;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Handler;
import au.com.codeka.planetrender.Colour;
import au.com.codeka.planetrender.Image;
import au.com.codeka.planetrender.PlanetRenderer;
import au.com.codeka.planetrender.Template;
import au.com.codeka.planetrender.TemplateException;
import au.com.codeka.planetrender.Vector3;

/**
 * Manages images of planets, generates images on-the-fly and caches them as
 * required.
 */
public class PlanetImageManager {
    private static PlanetImageManager sInstance = new PlanetImageManager();

    public static PlanetImageManager getInstance() {
        return sInstance;
    }

    private static Logger log = LoggerFactory.getLogger(PlanetImageManager.class);

    private Queue<QueuedGenerate> mGenerateQueue = new ArrayBlockingQueue<QueuedGenerate>(50);
    private Thread mGenerateThread;
    private Handler mHandler = new Handler();
    private List<BitmapGeneratedListener> mBitmapGeneratedListeners =
            new ArrayList<BitmapGeneratedListener>();
    private HashMap<String, SoftReference<Bitmap>> mLoadedBitmaps =
            new HashMap<String, SoftReference<Bitmap>>();
    private double mPixelScale;

    /**
     * Gets the \c Bitmap for the given planet. If no planet image has been generated
     * yet, \c null is returned and you should wait for the PlanetGenerated event.
     * 
     * To facilitate adding new images more easily, we check the asset directory each
     * time for the template. If the template would cause a different image to be
     * generated, then we don't return the cached image.
     * 
     * @param assetManager An \c AssetManager that we'll use to access the asset folder.
     * @param planet The \c Planet we want to generate an image for.
     * @return A \c Bitmap with an image of the planet, or \c null if the image has
     *          not been generated yet.
     */
    public Bitmap getBitmap(Context context, Planet planet) {
        SoftReference<Bitmap> loadedBitmap = mLoadedBitmaps.get(planet.getKey());
        if (loadedBitmap != null) {
            Bitmap bmp = loadedBitmap.get();
            if (bmp != null) {
                return bmp;
            }
        }

        if (isInGenerateQueue(planet)) {
            // if we've already queued up this planet, just give up now
            return null;
        }

        if (mPixelScale == 0) {
            mPixelScale = context.getResources().getDisplayMetrics().density;
        }

        long startTime = System.nanoTime();
        Template tmpl = getTemplate(context, planet);
        if (tmpl == null) {
            return null;
        }

        File cacheFile = new File(getCachePath(context, tmpl, planet));
        if (cacheFile.exists()) {
            log.debug("Loading cached image: "+cacheFile.getAbsolutePath());

            BitmapFactory.Options opts = new BitmapFactory.Options();
            Bitmap bmp = BitmapFactory.decodeFile(cacheFile.getAbsolutePath(), opts);

            mLoadedBitmaps.put(planet.getKey(), new SoftReference<Bitmap>(bmp));

            return bmp;
        } else {
            long endTime = System.nanoTime();
            log.debug(String.format("No cached image (after %.4fms), generating: %s",
                    (endTime - startTime) / 1000000.0,
                    cacheFile.getAbsolutePath()));

            addToGenerateQueue(new QueuedGenerate(tmpl, planet, cacheFile.getAbsolutePath()));
            ensureGenerateThread();

            return null;
        }
    }

    public void addBitmapGenerateListener(BitmapGeneratedListener listener) {
        mBitmapGeneratedListeners.add(listener);
    }

    public void removeBitmapGeneratedListener(BitmapGeneratedListener listener) {
        mBitmapGeneratedListeners.remove(listener);
    }

    protected void fireBitmapGeneratedListeners(final Planet planet, final Bitmap bmp) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                // make a copy, because sometimes they'll remove themselves in their own callback
                ArrayList<BitmapGeneratedListener> listeners =
                        new ArrayList<BitmapGeneratedListener>(mBitmapGeneratedListeners);

                for (BitmapGeneratedListener listener : listeners) {
                    listener.onBitmapGenerated(planet, bmp);
                }
            }
        });
    }

    /**
     * Gets the path to the cached version of the image generated by the given
     * \c Template.
     */
    private static String getCachePath(Context context, Template tmpl, Planet planet) {
        File cacheDir = context.getCacheDir();

        String fullPath = cacheDir.getAbsolutePath() + File.separator + "planets" + File.separator;
        fullPath += String.format("%s-%d-%d.png", tmpl.getName(),
                tmpl.getTemplateVersion(), planet.getKey().hashCode());

        return fullPath;
    }

    /**
     * Loads the \c Template for the given \c Planet.
     */
    private static Template getTemplate(Context context, Planet planet) {
        String basePath = planet.getPlanetType().getBitmapBasePath();

        String[] fileNames = null;
        try {
            fileNames = context.getAssets().list(basePath);
        } catch(IOException e) {
            return null; // should never happen!
        }

        // TODO: better seed
        long seed = planet.getKey().hashCode();
        Random rand = new Random(seed);

        String fullPath = basePath + "/";
        if (fileNames.length == 0) {
            return null;
        } else if (fileNames.length == 1) {
            fullPath += fileNames[0];
        } else {
            fullPath += fileNames[rand.nextInt(fileNames.length - 1)];
        }

        Template tmpl = null;
        InputStream ins = null;
        try {
            ins = context.getAssets().open(fullPath);
            tmpl = Template.parse(ins);
        } catch (IOException e) {
            log.error("Error loading planet definition: "+fullPath, e);
        } catch (TemplateException e) {
            log.error("Error parsing planet definition: "+fullPath, e);
        } finally {
            if (ins != null) {
                try {
                    ins.close();
                } catch (IOException e) {
                }
            }
        }

        if (tmpl != null) {
            tmpl.setName(fullPath.replace(File.separatorChar, '-').replace(".xml", ""));
        }

        return tmpl;
    }

    /**
     * Makes sure the generate thread is running, and spins one up if it's not.
     */
    private void ensureGenerateThread() {
        synchronized(mGenerateQueue) {
            if (mGenerateThread == null) {
                mGenerateThread = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        generateThreadProc();

                        // when it finishes, make sure we set the thread to null so
                        // we know to start it up again.
                        synchronized(mGenerateQueue) {
                            mGenerateThread = null;
                        }
                    }
                });

                // make it low priority -- UI must stay responsive!
                mGenerateThread.setPriority(Thread.MIN_PRIORITY);

                mGenerateThread.start();
            }
        }
    }

    private void generateThreadProc() {
        QueuedGenerate item;
        synchronized(mGenerateQueue) {
            item = mGenerateQueue.poll();
        }

        while (item != null) {
            generateBitmap(item.tmpl, item.planet, item.outputPath);

            synchronized(mGenerateQueue) {
                item = mGenerateQueue.poll();
            }
        }
    }

    private void addToGenerateQueue(QueuedGenerate item) {
        synchronized(mGenerateQueue) {
            // only add if we're not already generating this item
            if (!isInGenerateQueue(item.planet)) {
                mGenerateQueue.add(item);
            }
        }
    }

    /**
     * Checks whether we've already requests the given planet be generated (no need to
     * go through all the bother a second time).
     */
    private boolean isInGenerateQueue(Planet planet) {
        synchronized(mGenerateQueue) {
            boolean found = false;
            for (QueuedGenerate qg : mGenerateQueue) {
                if (qg.planet.getKey().equals(planet.getKey())) {
                    found = true;
                    break;
                }
            }

            return found;
        }
    }

    /**
     * This is called in a background to actually generate the bitmap.
     * @param tmpl
     * @param outputPath
     */
    private void generateBitmap(Template tmpl, Planet planet, String outputPath) {
        // we want to adjust the sun position so that shadows look correct when the planet is
        // drawn on the SolarSystem page.
        int numPlanets = planet.getStar().getNumPlanets();
        float angle = (0.5f/(numPlanets + 1));
        angle = (float) ((angle*planet.getIndex()*Math.PI) + angle*Math.PI);

        Vector3 sunDirection = new Vector3(0.0, 1.0, -1.0);
        sunDirection.rotateZ(angle);
        sunDirection.scale(200.0);

        Template.PlanetTemplate planetTemplate = (Template.PlanetTemplate) tmpl.getTemplate();
        planetTemplate.setSunLocation(sunDirection);

        // planet size ranges from 10 to 50, we convert that to 5..10 which is what we apply to
        // the planet renderer itself
        double size = ((planet.getSize() - 10.0) / 8.0) + 4.0;
        planetTemplate.setPlanetSize(size);

        // TODO: better seed
        long seed = planet.getKey().hashCode();
        Random rand = new Random(seed);

        PlanetRenderer renderer = new PlanetRenderer((Template.PlanetTemplate) tmpl.getTemplate(), rand);

        int imgSize = (int)(100 * mPixelScale);
        Image img = new Image(imgSize, imgSize, Colour.TRANSPARENT);
        renderer.render(img);

        Bitmap bmp = Bitmap.createBitmap(img.getArgb(), imgSize, imgSize, Bitmap.Config.ARGB_8888);

        File outputFile = new File(outputPath);
        File outputDirectory = new File(outputFile.getParent());
        if (!outputDirectory.exists()) {
            outputDirectory.mkdirs();
        }

        FileOutputStream fos;
        try {
            fos = new FileOutputStream(outputPath);
            bmp.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } catch (FileNotFoundException e) {
            log.error("Error writing to cache file.", e);
        }

        fireBitmapGeneratedListeners(planet, bmp);
    }

    class QueuedGenerate {
        public Template tmpl;
        public String outputPath;
        public Planet planet;

        public QueuedGenerate(Template tmpl, Planet planet, String outputPath) {
            this.tmpl = tmpl;
            this.outputPath = outputPath;
            this.planet = planet;
        }
    }

    public interface BitmapGeneratedListener {
        /**
         * This is called when the bitmap for the given planet has been generated.
         */
        void onBitmapGenerated(Planet planet, Bitmap bmp);
    }
}
